{"version":3,"file":"component---src-pages-pmrem-debug-tsx-4e3d11e26dc7c456dd57.js","mappings":"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","sources":["webpack://www/./node_modules/three/examples/jsm/loaders/RGBELoader.js","webpack://www/./src/pages/pmrem-debug.tsx","webpack://www/./src/pmrem.ts","webpack://www/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://www/./node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack://www/./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack://www/./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack://www/./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js"],"sourcesContent":["import _classCallCheck from \"/home/runner/work/irradiance-wasm/irradiance-wasm/www/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/runner/work/irradiance-wasm/irradiance-wasm/www/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"/home/runner/work/irradiance-wasm/irradiance-wasm/www/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _inherits from \"/home/runner/work/irradiance-wasm/irradiance-wasm/www/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _possibleConstructorReturn from \"/home/runner/work/irradiance-wasm/irradiance-wasm/www/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _getPrototypeOf from \"/home/runner/work/irradiance-wasm/irradiance-wasm/www/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { DataTextureLoader, DataUtils, FloatType, HalfFloatType, LinearEncoding, LinearFilter } from 'three'; // https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nvar RGBELoader = /*#__PURE__*/function (_DataTextureLoader) {\n  _inherits(RGBELoader, _DataTextureLoader);\n\n  var _super = _createSuper(RGBELoader);\n\n  function RGBELoader(manager) {\n    var _this;\n\n    _classCallCheck(this, RGBELoader);\n\n    _this = _super.call(this, manager);\n    _this.type = HalfFloatType;\n    return _this;\n  } // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n\n  _createClass(RGBELoader, [{\n    key: \"parse\",\n    value: function parse(buffer) {\n      var\n      /* return codes for rgbe routines */\n      //RGBE_RETURN_SUCCESS = 0,\n      RGBE_RETURN_FAILURE = -1,\n\n      /* default error routine.  change this to change error handling */\n      rgbe_read_error = 1,\n          rgbe_write_error = 2,\n          rgbe_format_error = 3,\n          rgbe_memory_error = 4,\n          rgbe_error = function rgbe_error(rgbe_error_code, msg) {\n        switch (rgbe_error_code) {\n          case rgbe_read_error:\n            console.error('THREE.RGBELoader Read Error: ' + (msg || ''));\n            break;\n\n          case rgbe_write_error:\n            console.error('THREE.RGBELoader Write Error: ' + (msg || ''));\n            break;\n\n          case rgbe_format_error:\n            console.error('THREE.RGBELoader Bad File Format: ' + (msg || ''));\n            break;\n\n          default:\n          case rgbe_memory_error:\n            console.error('THREE.RGBELoader: Error: ' + (msg || ''));\n        }\n\n        return RGBE_RETURN_FAILURE;\n      },\n\n      /* offsets to red, green, and blue components in a data (float) pixel */\n      //RGBE_DATA_RED = 0,\n      //RGBE_DATA_GREEN = 1,\n      //RGBE_DATA_BLUE = 2,\n\n      /* number of floats per pixel, use 4 since stored in rgba image format */\n      //RGBE_DATA_SIZE = 4,\n\n      /* flags indicating which fields in an rgbe_header_info are valid */\n      RGBE_VALID_PROGRAMTYPE = 1,\n          RGBE_VALID_FORMAT = 2,\n          RGBE_VALID_DIMENSIONS = 4,\n          NEWLINE = '\\n',\n          fgets = function fgets(buffer, lineLimit, consume) {\n        var chunkSize = 128;\n        lineLimit = !lineLimit ? 1024 : lineLimit;\n        var p = buffer.pos,\n            i = -1,\n            len = 0,\n            s = '',\n            chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n\n        while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n          s += chunk;\n          len += chunk.length;\n          p += chunkSize;\n          chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)));\n        }\n\n        if (-1 < i) {\n          /*for (i=l-1; i>=0; i--) {\n          \tbyteCode = m.charCodeAt(i);\n          \tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n          \telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n          \tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n          }*/\n          if (false !== consume) buffer.pos += len + i + 1;\n          return s + chunk.slice(0, i);\n        }\n\n        return false;\n      },\n\n      /* minimal header reading.  modify if you want to parse more information */\n      RGBE_ReadHeader = function RGBE_ReadHeader(buffer) {\n        // regexes to parse header info fields\n        var magic_token_re = /^#\\?(\\S+)/,\n            gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n            exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n            format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n            dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n            // RGBE format header struct\n        header = {\n          valid: 0,\n\n          /* indicate which fields are valid */\n          string: '',\n\n          /* the actual header string */\n          comments: '',\n\n          /* comments found in header */\n          programtype: 'RGBE',\n\n          /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */\n          format: '',\n\n          /* RGBE format, default 32-bit_rle_rgbe */\n          gamma: 1.0,\n\n          /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */\n          exposure: 1.0,\n\n          /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */\n          width: 0,\n          height: 0\n          /* image dimensions, width/height */\n\n        };\n        var line, match;\n\n        if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n          return rgbe_error(rgbe_read_error, 'no header found');\n        }\n        /* if you want to require the magic token then uncomment the next line */\n\n\n        if (!(match = line.match(magic_token_re))) {\n          return rgbe_error(rgbe_format_error, 'bad initial token');\n        }\n\n        header.valid |= RGBE_VALID_PROGRAMTYPE;\n        header.programtype = match[1];\n        header.string += line + '\\n';\n\n        while (true) {\n          line = fgets(buffer);\n          if (false === line) break;\n          header.string += line + '\\n';\n\n          if ('#' === line.charAt(0)) {\n            header.comments += line + '\\n';\n            continue; // comment line\n          }\n\n          if (match = line.match(gamma_re)) {\n            header.gamma = parseFloat(match[1]);\n          }\n\n          if (match = line.match(exposure_re)) {\n            header.exposure = parseFloat(match[1]);\n          }\n\n          if (match = line.match(format_re)) {\n            header.valid |= RGBE_VALID_FORMAT;\n            header.format = match[1]; //'32-bit_rle_rgbe';\n          }\n\n          if (match = line.match(dimensions_re)) {\n            header.valid |= RGBE_VALID_DIMENSIONS;\n            header.height = parseInt(match[1], 10);\n            header.width = parseInt(match[2], 10);\n          }\n\n          if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break;\n        }\n\n        if (!(header.valid & RGBE_VALID_FORMAT)) {\n          return rgbe_error(rgbe_format_error, 'missing format specifier');\n        }\n\n        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n          return rgbe_error(rgbe_format_error, 'missing image size specifier');\n        }\n\n        return header;\n      },\n          RGBE_ReadPixels_RLE = function RGBE_ReadPixels_RLE(buffer, w, h) {\n        var scanline_width = w;\n\n        if ( // run length encoding is not allowed so read flat\n        scanline_width < 8 || scanline_width > 0x7fff || // this file is not run length encoded\n        2 !== buffer[0] || 2 !== buffer[1] || buffer[2] & 0x80) {\n          // return the flat buffer\n          return new Uint8Array(buffer);\n        }\n\n        if (scanline_width !== (buffer[2] << 8 | buffer[3])) {\n          return rgbe_error(rgbe_format_error, 'wrong scanline width');\n        }\n\n        var data_rgba = new Uint8Array(4 * w * h);\n\n        if (!data_rgba.length) {\n          return rgbe_error(rgbe_memory_error, 'unable to allocate buffer space');\n        }\n\n        var offset = 0,\n            pos = 0;\n        var ptr_end = 4 * scanline_width;\n        var rgbeStart = new Uint8Array(4);\n        var scanline_buffer = new Uint8Array(ptr_end);\n        var num_scanlines = h; // read in each successive scanline\n\n        while (num_scanlines > 0 && pos < buffer.byteLength) {\n          if (pos + 4 > buffer.byteLength) {\n            return rgbe_error(rgbe_read_error);\n          }\n\n          rgbeStart[0] = buffer[pos++];\n          rgbeStart[1] = buffer[pos++];\n          rgbeStart[2] = buffer[pos++];\n          rgbeStart[3] = buffer[pos++];\n\n          if (2 != rgbeStart[0] || 2 != rgbeStart[1] || (rgbeStart[2] << 8 | rgbeStart[3]) != scanline_width) {\n            return rgbe_error(rgbe_format_error, 'bad rgbe scanline format');\n          } // read each of the four channels for the scanline into the buffer\n          // first red, then green, then blue, then exponent\n\n\n          var ptr = 0,\n              count = void 0;\n\n          while (ptr < ptr_end && pos < buffer.byteLength) {\n            count = buffer[pos++];\n            var isEncodedRun = count > 128;\n            if (isEncodedRun) count -= 128;\n\n            if (0 === count || ptr + count > ptr_end) {\n              return rgbe_error(rgbe_format_error, 'bad scanline data');\n            }\n\n            if (isEncodedRun) {\n              // a (encoded) run of the same value\n              var byteValue = buffer[pos++];\n\n              for (var i = 0; i < count; i++) {\n                scanline_buffer[ptr++] = byteValue;\n              } //ptr += count;\n\n            } else {\n              // a literal-run\n              scanline_buffer.set(buffer.subarray(pos, pos + count), ptr);\n              ptr += count;\n              pos += count;\n            }\n          } // now convert data from buffer into rgba\n          // first red, then green, then blue, then exponent (alpha)\n\n\n          var l = scanline_width; //scanline_buffer.byteLength;\n\n          for (var _i = 0; _i < l; _i++) {\n            var off = 0;\n            data_rgba[offset] = scanline_buffer[_i + off];\n            off += scanline_width; //1;\n\n            data_rgba[offset + 1] = scanline_buffer[_i + off];\n            off += scanline_width; //1;\n\n            data_rgba[offset + 2] = scanline_buffer[_i + off];\n            off += scanline_width; //1;\n\n            data_rgba[offset + 3] = scanline_buffer[_i + off];\n            offset += 4;\n          }\n\n          num_scanlines--;\n        }\n\n        return data_rgba;\n      };\n\n      var RGBEByteToRGBFloat = function RGBEByteToRGBFloat(sourceArray, sourceOffset, destArray, destOffset) {\n        var e = sourceArray[sourceOffset + 3];\n        var scale = Math.pow(2.0, e - 128.0) / 255.0;\n        destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale;\n        destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale;\n        destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale;\n        destArray[destOffset + 3] = 1;\n      };\n\n      var RGBEByteToRGBHalf = function RGBEByteToRGBHalf(sourceArray, sourceOffset, destArray, destOffset) {\n        var e = sourceArray[sourceOffset + 3];\n        var scale = Math.pow(2.0, e - 128.0) / 255.0; // clamping to 65504, the maximum representable value in float16\n\n        destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504));\n        destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504));\n        destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504));\n        destArray[destOffset + 3] = DataUtils.toHalfFloat(1);\n      };\n\n      var byteArray = new Uint8Array(buffer);\n      byteArray.pos = 0;\n      var rgbe_header_info = RGBE_ReadHeader(byteArray);\n\n      if (RGBE_RETURN_FAILURE !== rgbe_header_info) {\n        var w = rgbe_header_info.width,\n            h = rgbe_header_info.height,\n            image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h);\n\n        if (RGBE_RETURN_FAILURE !== image_rgba_data) {\n          var data, format, type;\n          var numElements;\n\n          switch (this.type) {\n            case FloatType:\n              numElements = image_rgba_data.length / 4;\n              var floatArray = new Float32Array(numElements * 4);\n\n              for (var j = 0; j < numElements; j++) {\n                RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4);\n              }\n\n              data = floatArray;\n              type = FloatType;\n              break;\n\n            case HalfFloatType:\n              numElements = image_rgba_data.length / 4;\n              var halfArray = new Uint16Array(numElements * 4);\n\n              for (var _j = 0; _j < numElements; _j++) {\n                RGBEByteToRGBHalf(image_rgba_data, _j * 4, halfArray, _j * 4);\n              }\n\n              data = halfArray;\n              type = HalfFloatType;\n              break;\n\n            default:\n              console.error('THREE.RGBELoader: unsupported type: ', this.type);\n              break;\n          }\n\n          return {\n            width: w,\n            height: h,\n            data: data,\n            header: rgbe_header_info.string,\n            gamma: rgbe_header_info.gamma,\n            exposure: rgbe_header_info.exposure,\n            format: format,\n            type: type\n          };\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"setDataType\",\n    value: function setDataType(value) {\n      this.type = value;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      function onLoadCallback(texture, texData) {\n        switch (texture.type) {\n          case FloatType:\n            texture.encoding = LinearEncoding;\n            texture.minFilter = LinearFilter;\n            texture.magFilter = LinearFilter;\n            texture.generateMipmaps = false;\n            texture.flipY = true;\n            break;\n\n          case HalfFloatType:\n            texture.encoding = LinearEncoding;\n            texture.minFilter = LinearFilter;\n            texture.magFilter = LinearFilter;\n            texture.generateMipmaps = false;\n            texture.flipY = true;\n            break;\n        }\n\n        if (onLoad) onLoad(texture, texData);\n      }\n\n      return _get(_getPrototypeOf(RGBELoader.prototype), \"load\", this).call(this, url, onLoadCallback, onProgress, onError);\n    }\n  }]);\n\n  return RGBELoader;\n}(DataTextureLoader);\n\nexport { RGBELoader };","import * as React from \"react\";\nimport { useEffect } from \"react\";\nimport { pmrem } from \"../pmrem\";\nexport default function PMREMDebug() {\n  const domID = \"pmremdebug\";\n  const width = 512;\n  const height = 512;\n  useEffect(() => {\n    pmrem(width, height, domID);\n  }, []);\n  return (\n    <div\n      id={domID}\n      style={{\n        height: height.toString() + \"px\",\n        width: width.toString() + \"px\",\n      }}\n    />\n  );\n}\n","import * as THREE from \"three\";\nimport {\n  ACESFilmicToneMapping,\n  Color,\n  Mesh,\n  MeshStandardMaterial,\n  PerspectiveCamera,\n  PMREMGenerator,\n  Scene,\n  TorusKnotGeometry,\n  WebGLRenderer,\n} from \"three\";\n// import { DebugEnvironment } from \"three/examples/jsm/environments/DebugEnvironment\";\n// import { HDRCubeTextureLoader } from \"three/examples/jsm/loaders/HDRCubeTextureLoader\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nimport { RGBELoader } from \"three/examples/jsm/loaders/RGBELoader\";\n\nexport function pmrem(width: number, height: number, domID: string) {\n  const camera = new PerspectiveCamera(40, width / height, 1, 1000);\n  camera.position.set(0, 0, 120);\n  const scene = new Scene();\n  scene.background = new Color(0x000000);\n\n  const renderer = new WebGLRenderer();\n  document.getElementById(domID).appendChild(renderer.domElement);\n\n  renderer.physicallyCorrectLights = true;\n  renderer.toneMapping = ACESFilmicToneMapping;\n\n  let geometry = new TorusKnotGeometry(18, 8, 150, 20);\n  // let geometry = new THREE.SphereGeometry( 26, 64, 32 );\n  let material = new MeshStandardMaterial({\n    color: 0xffffff,\n    metalness: 0.68,\n    roughness: 0.08,\n  });\n\n  const torusMesh = new Mesh(geometry, material);\n  scene.add(torusMesh);\n\n  const geometry2 = new THREE.PlaneGeometry(200, 200);\n  const material2 = new THREE.MeshBasicMaterial();\n\n  const planeMesh = new THREE.Mesh(geometry2, material2);\n  planeMesh.position.y = -50;\n  planeMesh.rotation.x = -Math.PI * 0.5;\n  scene.add(planeMesh);\n\n  // new TextureLoader().load(\"uv_grid_opengl.jpg\", (map) => {\n  //   const xx = _createPlanes(7);\n  //   console.log(xx);\n  //   const { lodPlanes } = xx;\n  //   let cnt = 0;\n  //   lodPlanes.forEach((lodPlane) => {\n  //     const m = new Mesh(lodPlane, new MeshBasicMaterial({ map }));\n  //     m.translateZ(cnt++);\n  //     m.translateX(500);\n  //     m.translateY(100);\n  //     scene.add(m);\n  //   });\n  // });\n\n  const pmremGenerator = new PMREMGenerator(renderer);\n  pmremGenerator.compileCubemapShader();\n\n  // const envScene = new DebugEnvironment();\n  // const generatedCubeRenderTarget = pmremGenerator.fromScene(envScene);\n\n  renderer.setPixelRatio(window.devicePixelRatio);\n  renderer.setSize(width, height);\n\n  const render = () => {\n    renderer.render(scene, camera);\n  };\n  new RGBELoader().load(\"venetian_crossroads_1k.hdr\", (dataTexture) => {\n    // hdrCubeMap.magFilter = THREE.LinearFilter;\n    // hdrCubeMap.needsUpdate = true;\n\n    const renderTarget = pmremGenerator.fromEquirectangular(dataTexture);\n    // const cubeMap = hdrCubeMap;\n\n    const newEnvMap = renderTarget ? renderTarget.texture : null;\n\n    if (newEnvMap && newEnvMap !== torusMesh.material.envMap) {\n      torusMesh.material.envMap = newEnvMap;\n      torusMesh.material.needsUpdate = true;\n\n      planeMesh.material.map = newEnvMap;\n      planeMesh.material.needsUpdate = true;\n    }\n\n    torusMesh.rotation.y += 0.005;\n    planeMesh.visible = true;\n\n    // scene.background = cubeMap;\n    renderer.toneMappingExposure = 1;\n    render();\n  });\n\n  //renderer.toneMapping = ReinhardToneMapping;\n  renderer.outputEncoding = THREE.sRGBEncoding;\n  const controls = new OrbitControls(camera, renderer.domElement);\n  controls.minDistance = 50;\n  controls.maxDistance = 300;\n  controls.addEventListener(\"change\", render);\n}\n","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArrayLimit from \"./iterableToArrayLimit.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","export default function _iterableToArrayLimit(arr, i) {\n  var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"];\n\n  if (_i == null) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n\n  var _s, _e;\n\n  try {\n    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}"],"names":["_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","prototype","valueOf","call","e","_isNativeReflectConstruct","result","Super","NewTarget","this","constructor","arguments","apply","RGBELoader","_DataTextureLoader","_super","manager","_this","type","key","value","buffer","rgbe_error","rgbe_error_code","msg","console","error","fgets","lineLimit","consume","p","pos","i","len","s","chunk","String","fromCharCode","Uint16Array","subarray","indexOf","byteLength","length","slice","RGBEByteToRGBHalf","sourceArray","sourceOffset","destArray","destOffset","scale","Math","pow","min","byteArray","Uint8Array","rgbe_header_info","line","match","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","width","height","charAt","parseFloat","parseInt","RGBE_ReadHeader","w","h","image_rgba_data","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","ptr","count","isEncodedRun","byteValue","set","l","_i","off","RGBE_ReadPixels_RLE","data","numElements","floatArray","Float32Array","j","halfArray","_j","url","onLoad","onProgress","onError","texture","texData","encoding","minFilter","magFilter","generateMipmaps","flipY","PMREMDebug","domID","useEffect","camera","PerspectiveCamera","position","scene","Scene","background","Color","renderer","WebGLRenderer","document","getElementById","appendChild","domElement","physicallyCorrectLights","toneMapping","ACESFilmicToneMapping","geometry","TorusKnotGeometry","material","MeshStandardMaterial","color","metalness","roughness","torusMesh","Mesh","add","geometry2","THREE","material2","planeMesh","y","rotation","x","PI","pmremGenerator","PMREMGenerator","compileCubemapShader","setPixelRatio","window","devicePixelRatio","setSize","render","load","dataTexture","renderTarget","fromEquirectangular","newEnvMap","envMap","needsUpdate","map","visible","toneMappingExposure","outputEncoding","controls","OrbitControls","minDistance","maxDistance","addEventListener","pmrem","id","style","toString","_defineProperty","obj","Object","defineProperty","enumerable","configurable","writable","_slicedToArray","arr","Array","isArray","Symbol","iterator","_s","_e","_arr","_n","_d","next","done","push","err","unsupportedIterableToArray","TypeError"],"sourceRoot":""}